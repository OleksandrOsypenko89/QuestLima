{
  "2001": {
    "id": 2001,
    "question": "Что такое дженерики?",
    "answer": "Дженерики – это параметризованные типы. С их помощью можно объявлять классы, интерфейсы и методы, в которых тип данных указан в виде параметра. Используя дженерики, можно создать единственный класс, который будет автоматически работать с разными типами данных. Эта информация доступна только на этапе компиляции и стирается в runtime, и в байт код попадет только информация о том, что в программе есть некий список List&ltObject&gt list вместо List&ltString&gt list, например. Появились в версии 1.5"
  },
  "2002": {
    "id": 2002,
    "question": "Для чего нужны дженерики?",
    "answer": "Для строгой типизации и проверки на этапе компиляции. Дженерики позволяют передавать тип объекта компилятору в форме <тип>. Таким образом, компилятор может выполнить все необходимые действия по проверке типов во время компиляции, обеспечивая безопасность по приведению типов во время выполнения."
  },
  "2003": {
    "id": 2003,
    "question": "Что такое сырые типы (raw type)?",
    "answer": "Сырые типы — это типы без указания типа в фигурных скобках ( List list = new ArrayList<>() ), они использовались до появления дженериков. Не указывая их, под капотом используется Object."
  },
  "2004": {
    "id": 2004,
    "question": "Что такое вайлдкарды?",
    "answer": "Маске (wildcard) можно задать ограничения: <p>-“? extends T” (для получения в методе)  - объект, который наследуется от Т, либо сам Т – ковариантность. Если контейнер объявлен ? extends T, то можно только читать значения. В список нельзя ничего добавить, кроме null.<p>-“? super T” (для отдачи в методе) - любой объект подтипа Т, включая Т – контравариантность. Нельзя прочитать элемент из контейнера с wildcard ? super, кроме объекта класса Object <p>При использовании ? мы сообщаем компилятору, чтобы он игнорировал информацию о типе, т.е. <?> - неограниченный символ подстановки. <?> означает то же что и <? extends Object>, т.е. принимает всё. Это можно обойти, создав обобщенный метод, объявленный с переменной типа T."
  },
  "2005": {
    "id": 2005,
    "question": "Расскажите про принцип PECS",
    "answer": "Producer Extends Consumer Super <p>wildcard подстановочный знак: <p>Если мы объявили wildcard с extends, то это producer. Он только «производит», предоставляет элемент из контейнера, а сам ничего не принимает. <p>Если же мы объявили wildcard с super — то это consumer. Он только принимает, а предоставить ничего не может. <p>Иначе говоря: <p>Если вы только получаете объекты из дженерик-коллекции - это producer и надо использовать extends. <p>Если вы только кладете объекты в коллекцию - это consumer и надо использовать super. <p>Если вы делаете оба эти действия, то не надо использовать ни super, ни extends."
  },
  "2006": {
    "id": 2006,
    "question": "Что такое «коллекция»?",
    "answer": "Коллекция – это объект, который содержит набор объектов одного типа. Каждый из этих объектов в коллекции называется элементом."
  },



  "2008": {
    "id": 2008,
    "question": "Почему Map — это не Collection, в то время как List и Set являются Collection?",
    "answer": "Коллекция (List и Set) представляет собой совокупность некоторых элементов (обычно экземпляров одного класса).Map -это совокупность пар &#8222ключ&#8221-&#8222значение&#8221. У map нет итерабл, не понятно по чему проводить итерацию"
  },
  "2009": {
    "id": 2009,
    "question": "В чем разница между java.util.Collection и java.util.Collections?",
    "answer": "Класс java.util.Collections содержит исключительно статические методы для работы с коллекциями. В них входят методы, реализующие полиморфные алгоритмы (такие алгоритмы, использование которых возможно с разными видами структур данных), &#8222оболочки&#8221, возвращающие новую коллекцию с инкапсулированной указанной структурой данных и некоторые другие методы. <p>sort () - сортирует по порядку;  <p>binarySearch () - деление напополам для быстрого поиска;  <p>reverse () - сортировка по убыванию; <p>copy() - копирует; <p>java.util.Collection - это корневой интерфейс Java Collections Framework. Этот интерфейс в основном применяется там, где требуется высокий уровень абстракции, например, в классе java.util.Collections. Классы реализующие Collection, могут добавлять, убирать, искать элементы коллекций. <p>Collection — это интерфейс, который содержит статический метод, начиная с java8. Интерфейс также может содержать абстрактные методы и методы по умолчанию. Он используется для представления группы отдельных объектов как единого целого. <p>Collections - класс, содержит только статические методы. Он определяет несколько служебных методов, которые используются для работы с коллекцией."
  },
  "2010": {
    "id": 2010,
    "question": "Какая разница между итераторами с fail-fast и fail-safe поведением? (С примерами)",
    "answer": "Никаких модификаций не допускается. Изменений структуры коллекции, уменьшать, добавлять... <p>Итератор fail-safe проходимся по коллекции и не вылетает ошибка при попытке удалить элемент, не вызывает исключений при изменении структуры коллекции, потому что работает с её клоном. Пример fail-safe -Итератор коллекции CopyOnWriteArrayList и итератор представления keySet коллекции ConcurrentHashMap. <p>Итератор fail-fast проходя по коллекции вылетает ошибка, т.к. проходим по коллекции пытаемся удалить элемент, генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, но работает быстрее. Пример fail-fast - Vector и Hashtable. fail-fast поведение означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает дальнейшую работу и уведомляет об этом. Использование fail-fast подхода позволяет избежать недетерминированного поведения программы в течение времени. В Java Collections API некоторые итераторы ведут себя как fail-fast и выбрасывают ConcurrentModificationException, если после его создания была произведена модификация коллекции, т.е. добавлен или удален элемент напрямую из коллекции, а не используя методы итератора. <p>Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count): <p>- при изменении коллекции счетчик модификаций также изменяется; <p>- при создании итератора ему передается текущее значение счетчика; <p>- при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение. <p>Разница, при удалении значений и при добавлении значений. Добавление в конец, удаление может быть где удобно. <p>Fail-safe – «умный» итератор. Обычно плата за отказоустойчивость – возможная неконсистентность данных («слабая консистентность»). Итератор класса ConcurrentHashMap работает с копией данных, он не выбросит исключение при изменении коллекции, но может не увидеть часть свежих изменений. Плата за отсутствие ошибок других fail-safe итераторов может отличаться, детали всегда можно найти в документации коллекций. <p>Fail-fast – «быстрый» итератор. Когда после его создания коллекция как-либо изменилась, он падает с ошибкой без лишних разбирательств. Так работает итератор класса ArrayList, при изменении он выбрасывает ConcurrentModificationException. Рекомендуется не основывать логику программы на fail-fast отказах, и использовать их только как признак ошибки реализации."
  },
  "2011": {
    "id": 2011,
    "question": "Чем различаются Enumeration и Iterator?",
    "answer": "Iterator имеет больше методов работы с коллекциями и был специально введен в java2, вместо Enumeration(interface). Рекомендуется юзать Iterator. <p>Оба интерфейса предназначены для обхода коллекции, но есть различия: <p>-с помощью Enumeration нельзя добавлять/удалять элементы; <p>-в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д); <p>-Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных коллекциях."
  }

}